<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Data Structure -- Stack</title>
    <url>/2021/11/15/Data-Structure-Stack/</url>
    <content><![CDATA[<h1 id="What-is-stack"><a href="#What-is-stack" class="headerlink" title="What is stack"></a>What is stack</h1><p>Stack is a data structure that follow <strong>LIFO</strong> pricinple, new element are added in the end (push), and deletion of element also start from the end(pop)</p>
<span id="more"></span>

<p>In python, we can implement a stack simply by using a list, by using list.append or list.pop we can add/remove last element in list. If we want a faster insertion or deletion, we can use <strong>deque</strong>. Deque support fast insertion/deletion in both end of the array.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#implementaion with deque</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_example</span>():</span></span><br><span class="line">	example = deque()</span><br><span class="line">	example.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(example)</span><br><span class="line">	example.pop()</span><br><span class="line">	<span class="built_in">print</span>(example)</span><br></pre></td></tr></table></figure>

<h2 id="What-can-stack-be-used-for"><a href="#What-can-stack-be-used-for" class="headerlink" title="What can stack be used for?"></a>What can stack be used for?</h2><h3 id="Next-greater-element"><a href="#Next-greater-element" class="headerlink" title="Next greater element"></a>Next greater element</h3><p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p>
<p>Use leetcode question #496 as example</p>
<p><a href="https://leetcode.com/problems/next-greater-element-i/">LeetCode Link</a></p>
<p>To solve the problem, stack can be very useful.<br>We can create a hash table to store the result, and a stack to store the element we walk through.<br>Then we follow below logic:<br>Everytime we walk to a new element, compare it with the last element in stack.<br>If it is greater than the last element of stack, we can update the hash table and store down the result. And we <strong>pop</strong> the last element of stack.<br>We keep doing this until there are no element left in stack or stack[-1] &gt; new element<br>If not , we append the new element into the stack. then go to next element.</p>
<p>Notice that in the stack, it is always sorted in descending order, as every new element added would be less than or equal to last element in stack, so it can only be in descending order, which make it a <strong>monotonic stack</strong>.</p>
<p>The implementation of above leetcode quesion could look as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        table = &#123;&#125;            </span><br><span class="line">        <span class="comment">#fill next greater element</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i]&gt;stack[-<span class="number">1</span>]:</span><br><span class="line">                table[stack[-<span class="number">1</span>]] = nums2[i]</span><br><span class="line">                stack.pop()</span><br><span class="line">                </span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> stack:</span><br><span class="line">            table[ele] = -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        ans = [table[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h3><p>To do a inorder traversal , the order go like this left node –&gt; root –&gt; right node</p>
<p>The way to do so in stack is to walk through the node on left side first, put it in stack . Once we have reach the left node, we pop the last element in stack and add it to ans array. then we go to the right node and add it to stack and proceed.</p>
<p>The implementaion can look like this</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">		stack = []</span><br><span class="line">		ans = []</span><br><span class="line"></span><br><span class="line">		cur = root</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> stack !=[]:</span><br><span class="line">			<span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				stack.append(cur)</span><br><span class="line">				cur = cur.left</span><br><span class="line">			cur = stack.pop()</span><br><span class="line">			ans.append(cur.val)</span><br><span class="line">			cur = cur.right</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
</search>
