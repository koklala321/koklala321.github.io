<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Data Structure -- Stack</title>
    <url>/2021/11/15/Data-Structure-Stack/</url>
    <content><![CDATA[<h1 id="What-is-stack"><a href="#What-is-stack" class="headerlink" title="What is stack"></a>What is stack</h1><p>Stack is a data structure that follow <strong>LIFO</strong> pricinple, new element are added in the end (push), and deletion of element also start from the end(pop)</p>
<span id="more"></span>

<p>In python, we can implement a stack simply by using a list, by using list.append or list.pop we can add/remove last element in list. If we want a faster insertion or deletion, we can use <strong>deque</strong>. Deque support fast insertion/deletion in both end of the array.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#implementaion with deque</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_example</span>():</span></span><br><span class="line">	example = deque()</span><br><span class="line">	example.append(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	<span class="built_in">print</span>(example)</span><br><span class="line">	example.pop()</span><br><span class="line">	<span class="built_in">print</span>(example)</span><br></pre></td></tr></table></figure>

<h2 id="What-can-stack-be-used-for"><a href="#What-can-stack-be-used-for" class="headerlink" title="What can stack be used for?"></a>What can stack be used for?</h2><h3 id="Next-greater-element"><a href="#Next-greater-element" class="headerlink" title="Next greater element"></a>Next greater element</h3><p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p>
<p>Use leetcode question #496 as example</p>
<p><a href="https://leetcode.com/problems/next-greater-element-i/">LeetCode Link</a></p>
<p>To solve the problem, stack can be very useful.<br>We can create a hash table to store the result, and a stack to store the element we walk through.<br>Then we follow below logic:<br>Everytime we walk to a new element, compare it with the last element in stack.<br>If it is greater than the last element of stack, we can update the hash table and store down the result. And we <strong>pop</strong> the last element of stack.<br>We keep doing this until there are no element left in stack or stack[-1] &gt; new element<br>If not , we append the new element into the stack. then go to next element.</p>
<p>Notice that in the stack, it is always sorted in descending order, as every new element added would be less than or equal to last element in stack, so it can only be in descending order, which make it a <strong>monotonic stack</strong>.</p>
<p>The implementation of above leetcode quesion could look as follow:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        table = &#123;&#125;            </span><br><span class="line">        <span class="comment">#fill next greater element</span></span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums2[i]&gt;stack[-<span class="number">1</span>]:</span><br><span class="line">                table[stack[-<span class="number">1</span>]] = nums2[i]</span><br><span class="line">                stack.pop()</span><br><span class="line">                </span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> stack:</span><br><span class="line">            table[ele] = -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        ans = [table[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]   </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h3 id="Binary-Tree-Inorder-Traversal"><a href="#Binary-Tree-Inorder-Traversal" class="headerlink" title="Binary Tree Inorder Traversal"></a>Binary Tree Inorder Traversal</h3><p>To do a inorder traversal , the order go like this left node –&gt; root –&gt; right node</p>
<p>The way to do so in stack is to walk through the node on left side first, put it in stack . Once we have reach the left node, we pop the last element in stack and add it to ans array. then we go to the right node and add it to stack and proceed.</p>
<p>The implementaion can look like this</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">		stack = []</span><br><span class="line">		ans = []</span><br><span class="line"></span><br><span class="line">		cur = root</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> stack !=[]:</span><br><span class="line">			<span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">				stack.append(cur)</span><br><span class="line">				cur = cur.left</span><br><span class="line">			cur = stack.pop()</span><br><span class="line">			ans.append(cur.val)</span><br><span class="line">			cur = cur.right</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Making a sudoku game with Python I -- The sudoku generator</title>
    <url>/2021/11/18/Making-a-sudoku-game-with-Python-I/</url>
    <content><![CDATA[<h1 id="Making-a-sudoku-game-with-Python"><a href="#Making-a-sudoku-game-with-Python" class="headerlink" title="Making a sudoku game with Python"></a>Making a sudoku game with Python</h1><p>To make a sudoku game with python, we first have to think about how a sudoku game work.</p>
<p>First, we need to have a board of 9*9 grid , with some empty space that we can fill in (which is the point of sudoku)</p>
<p>this can be divided into 2 parts, </p>
<ol>
<li>We have generate a grid full of number that fit to sudoku rule</li>
<li>Then we have to remove cells one by one, and make sure there can only be one solution everytime we remove a cells</li>
</ol>
<p>After preparing the board, we need to prepare a function that allow user to input number, and if possible, prevent user from entering the wrong number/invalid input.</p>
<p>And finnally, we need to make a function to check if the answer (finished board) from user is correct, or not.</p>
<span id="more"></span>

<h1 id="The-sudoku-generator"><a href="#The-sudoku-generator" class="headerlink" title="The sudoku generator"></a>The sudoku generator</h1><p>But putting all 4 parts above in one post could be quite overwhelming, so it would be better to start by making a valid sudoku board first.</p>
<p>Here is a of list of important function that we need to build</p>
<ol>
<li><p>A function to check if a input follow sudoku rule – check row, check column and check square</p>
</li>
<li><p>A function that use the above checking function , generate random input to fill up a board(A sudoku generator)</p>
</li>
<li><p>A function that can help randomly remove cell content a generate a playable sudoku</p>
</li>
<li><p>A function to similar to 2, but act as a solver, everytime a cell is removed, it can check how many solution are there.(A good sudoku should only has one solution)</p>
</li>
</ol>
<h2 id="The-checking-function"><a href="#The-checking-function" class="headerlink" title="The checking function"></a>The checking function</h2><p>Let’s start with function 1:</p>
<p>The below block of code is used to check if a new input is valid under the col/row rule of sudoku for specific grid.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the check_rowcolumn function is to check if input number is duplciated in row/column</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_rowcolumn</span>(<span class="params">current_row:<span class="built_in">int</span>,current_column:<span class="built_in">int</span>,grid:<span class="built_in">list</span>,number:<span class="built_in">int</span></span>):</span> <span class="comment">#1,8</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">if</span> grid[i][current_column]== number:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">if</span> grid[current_row][j] == number:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>And the below block is used for checking the 3*3 square </p>
<p>One tricky part is that we need to we only start at row/col 0,3,6.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#the check_square function is to check if the number input is duplcated in square(3*3)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_square</span>(<span class="params">current_row:<span class="built_in">int</span>,current_column:<span class="built_in">int</span>,grid:<span class="built_in">list</span>,number:<span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="comment">#check by 3*3 square for current value</span></span><br><span class="line">    current_row = current_row - (current_row % <span class="number">3</span>)</span><br><span class="line">    current_column = current_column - (current_column % <span class="number">3</span>)</span><br><span class="line">    <span class="comment">#start checking if this square has invalid value</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> grid[current_row+x][current_column+y] == number:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment">#else:</span></span><br><span class="line">                <span class="comment">#check.add(grid[i+x][j+y])</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="To-fill-the-board"><a href="#To-fill-the-board" class="headerlink" title="To fill the board"></a>To fill the board</h2><p>Now that the checking function is finished, the next step is to generate a filled valid board using recursion and backtracking</p>
<p>To generate the filled valid board, we need to make sure the following,</p>
<ol>
<li>the input must be random</li>
<li>We need to find the location of the next valid cell</li>
<li>everytime there is a new input, we check it with checking function to see if it pass</li>
<li>we should backtrack and return to previous stack when meeting dead end, try another input in previous stack</li>
</ol>
<p>The finished function look like this</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_grid</span>(<span class="params">grid:<span class="built_in">list</span></span>):</span></span><br><span class="line">    random.shuffle(valid_number)</span><br><span class="line">    <span class="comment">#define base case</span></span><br><span class="line">    emtpy_cell = find_empty(grid) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> emtpy_cell:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:   </span><br><span class="line">        <span class="comment">#mark next empty celxl</span></span><br><span class="line">        i,j = emtpy_cell</span><br><span class="line">    <span class="comment">#loop through 1-9</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> valid_number:</span><br><span class="line">        <span class="keyword">if</span> check_rowcolumn(i,j,grid,value):</span><br><span class="line">            <span class="keyword">if</span> check_square(i,j,grid,value):</span><br><span class="line">                grid[i][j] = value</span><br><span class="line">                <span class="comment">#print(grid[i][j])</span></span><br><span class="line">                <span class="keyword">if</span> fill_grid(grid):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    grid[i][j]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="Detail-break-down"><a href="#Detail-break-down" class="headerlink" title="Detail break down"></a>Detail break down</h3><p>The base case to stop the recursion is when there is no more empty cell, which I use the find empty function below to locate empty cell</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_empty</span>(<span class="params">grid:<span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i,j</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>if empty cell is found, we use the checkrow/col and check square function to check if the current randomly generated number fit</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> valid_number:</span><br><span class="line">    <span class="keyword">if</span> check_rowcolumn(i,j,grid,value):</span><br><span class="line">        <span class="keyword">if</span> check_square(i,j,grid,value):</span><br><span class="line">            grid[i][j] = value</span><br></pre></td></tr></table></figure>

<p>After that we recursively run the function again and proceed to next empty cell, and only stop when the current stack return True, , which is when the base case is met</p>
<p>And after the whole for loop, here come the key point of backtracking, <strong>grid[i][j]=0</strong>, we need to backtrack and return current cell value to 0.<br>Let’s think of an example like this, we have find ourself in a dead end where all 9 numbers can not fit in next empty cell, that means we have to proceed on next valid number in previous stack.<br>And if the remaining number in number list are not valid, that mean we have to 0 the current cell again, as number in current cell lead to dead end. Then we can go back to previous stack and repeat above process, until we find a new number that can make all the coming stack pass.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> valid_number:</span><br><span class="line">    <span class="keyword">if</span> check_rowcolumn(i,j,grid,value):</span><br><span class="line">        <span class="keyword">if</span> check_square(i,j,grid,value):</span><br><span class="line">            grid[i][j] = value</span><br><span class="line">            <span class="comment">#print(grid[i][j])</span></span><br><span class="line">            <span class="keyword">if</span> fill_grid(grid):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">grid[i][j]=<span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>And this is pretty much the logic behind the generator, but a generator alone is not enough, as we then have to build function 3(remove cell) and function 4(check solution) mentioned above, if we need to build a valid board.<br>For that I will update it in later blog post.</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
</search>
